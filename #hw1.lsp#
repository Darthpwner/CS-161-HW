
; Problem 1
(defun TREE-CONTAINS(N TREE)
	(cond ((NULL TREE) NIL);	Empty tree should return nil
		((equal N (first TREE)) t);	If N is equal to the first element, return true
		(t (TREE-CONTAINS N (rest TREE))));	Recursively search the rest of the tree
	)
)

; Problem 2 
(defun TREE-MAX(TREE)
	(let (initial_max (first TREE) ) )
	(let (absolute_max (TREE-MAX(rest TREE)) ) )

	(cond (> initial_max absolute_max) initial_max
		(t (absolute_max))
	) 
)

; Problem 3
; Tree is assumed to be already in order
(defun TREE-ORDER(TREE)
	(cond ((NULL TREE) <list>);	Return the tree as a list at the end
		(cons (first TREE) <list>) ;	Add nodes to the list
		(t (TREE-ORDER (rest TREE)));	Traverse the rest of the tree
	)
)

; Problem 4
(defun SUB-LIST(L START LEN)

)

; Problem 5
(defun SPLIT-LIST(L)

)

; Problem 6
(defun BTREE-HEIGHT(TREE)

)

; Problem 7
(defun LIST2BTREE(LEAVES)

)

; Problem 8
(defun BTREE2LIST(TREE)

)

(load (TREE-CONTAINS 3 3)
